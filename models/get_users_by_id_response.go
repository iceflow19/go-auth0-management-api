// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetUsersByIDResponse get users by id response
// swagger:model get_users_by_id_response
type GetUsersByIDResponse struct {

	// app metadata
	AppMetadata GetUsersByIDResponseAppMetadata `json:"app_metadata,omitempty"`

	// Indicates whether the user was blocked by an administrator or not
	Blocked bool `json:"blocked,omitempty"`

	// The date when the user was created
	CreatedAt string `json:"created_at,omitempty"`

	// The user's email
	// Format: email
	Email *strfmt.Email `json:"email,omitempty"`

	// <code>true</code> if the user's email is verified, <code>false</code> otherwise
	EmailVerified *bool `json:"email_verified,omitempty"`

	// The user's family name
	FamilyName string `json:"family_name,omitempty"`

	// The user's given name
	GivenName string `json:"given_name,omitempty"`

	// An array of objects with information about the user's identities. More than one will exists in case accounts are linked
	Identities []*GetUsersByIDResponseIdentitiesItems0 `json:"identities"`

	// The last login IP address
	LastIP string `json:"last_ip,omitempty"`

	// The last login date for this user
	LastLogin string `json:"last_login,omitempty"`

	// The number of logins for this user
	LoginsCount int64 `json:"logins_count,omitempty"`

	// The list of multifactor providers that the user has enrolled to
	Multifactor []string `json:"multifactor"`

	// The user's name
	Name string `json:"name,omitempty"`

	// The user's nickname
	Nickname string `json:"nickname,omitempty"`

	// The user's phone number (following the E.164 recommendation), only valid for users from SMS connections
	PhoneNumber *string `json:"phone_number,omitempty"`

	// <code>true</code> if the user's phone_number is verified, <code>false</code> otherwise, only valid for users from SMS connections
	PhoneVerified *bool `json:"phone_verified,omitempty"`

	// The user's picture
	Picture string `json:"picture,omitempty"`

	// The date when the user was last updated (modified)
	UpdatedAt string `json:"updated_at,omitempty"`

	// The user's unique identifier
	UserID *string `json:"user_id,omitempty"`

	// user metadata
	UserMetadata GetUsersByIDResponseUserMetadata `json:"user_metadata,omitempty"`

	// The user's username
	Username *string `json:"username,omitempty"`
}

// Validate validates this get users by id response
func (m *GetUsersByIDResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdentities(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetUsersByIDResponse) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.FormatOf("email", "body", "email", m.Email.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *GetUsersByIDResponse) validateIdentities(formats strfmt.Registry) error {

	if swag.IsZero(m.Identities) { // not required
		return nil
	}

	for i := 0; i < len(m.Identities); i++ {
		if swag.IsZero(m.Identities[i]) { // not required
			continue
		}

		if m.Identities[i] != nil {
			if err := m.Identities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("identities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetUsersByIDResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetUsersByIDResponse) UnmarshalBinary(b []byte) error {
	var res GetUsersByIDResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetUsersByIDResponseIdentitiesItems0 get users by ID response identities items0
// swagger:model GetUsersByIDResponseIdentitiesItems0
type GetUsersByIDResponseIdentitiesItems0 struct {

	// IDP access token returned only if scope read:user_idp_token is defined
	AccessToken string `json:"access_token,omitempty"`

	// The name of the connection for the identity
	Connection string `json:"connection,omitempty"`

	// <code>true</code> if the identity provider is a social provider, <code>false</code>s otherwise
	IsSocial bool `json:"isSocial,omitempty"`

	// profile data
	ProfileData *GetUsersByIDResponseIdentitiesItems0ProfileData `json:"profileData,omitempty"`

	// The type of identity provider
	Provider string `json:"provider,omitempty"`

	// The unique identifier for the user for the identity
	UserID string `json:"user_id,omitempty"`
}

// Validate validates this get users by ID response identities items0
func (m *GetUsersByIDResponseIdentitiesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProfileData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetUsersByIDResponseIdentitiesItems0) validateProfileData(formats strfmt.Registry) error {

	if swag.IsZero(m.ProfileData) { // not required
		return nil
	}

	if m.ProfileData != nil {
		if err := m.ProfileData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profileData")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetUsersByIDResponseIdentitiesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetUsersByIDResponseIdentitiesItems0) UnmarshalBinary(b []byte) error {
	var res GetUsersByIDResponseIdentitiesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetUsersByIDResponseIdentitiesItems0ProfileData get users by ID response identities items0 profile data
// swagger:model GetUsersByIDResponseIdentitiesItems0ProfileData
type GetUsersByIDResponseIdentitiesItems0ProfileData struct {

	// The user's email
	Email string `json:"email,omitempty"`

	// Indicates whether the user's email is verified or not
	EmailVerified bool `json:"email_verified,omitempty"`

	// The user's family name
	FamilyName string `json:"family_name,omitempty"`

	// The user's given name
	GivenName string `json:"given_name,omitempty"`

	// The user's name
	Name string `json:"name,omitempty"`

	// The user's phone number
	PhoneNumber string `json:"phone_number,omitempty"`

	// Indicates whether the user's phone is verified or not
	PhoneVerified bool `json:"phone_verified,omitempty"`

	// The user's username
	Username *string `json:"username,omitempty"`
}

// Validate validates this get users by ID response identities items0 profile data
func (m *GetUsersByIDResponseIdentitiesItems0ProfileData) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetUsersByIDResponseIdentitiesItems0ProfileData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetUsersByIDResponseIdentitiesItems0ProfileData) UnmarshalBinary(b []byte) error {
	var res GetUsersByIDResponseIdentitiesItems0ProfileData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
