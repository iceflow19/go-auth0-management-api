// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchClientsByIDBody patch clients by id body
// swagger:model patch_clients_by_id_body
type PatchClientsByIDBody struct {

	// addons
	Addons *PatchClientsByIDBodyAddons `json:"addons,omitempty"`

	// Ids of clients that will be allowed to perform delegation requests. Clients that will be allowed to make delegation request. By default, all your clients will be allowed. This field allows you to specify specific clients
	// Unique: true
	AllowedClients []string `json:"allowed_clients"`

	// A set of URLs that are valid to redirect to after logout from Auth0
	// Unique: true
	AllowedLogoutUrls []string `json:"allowed_logout_urls"`

	// A set of URLs that represents valid origins for CORS
	// Unique: true
	AllowedOrigins []string `json:"allowed_origins"`

	// The type of application this client represents
	// Enum: [native spa regular_web non_interactive rms box cloudbees concur dropbox mscrm echosign egnyte newrelic office365 salesforce sentry sharepoint slack springcm zendesk zoom]
	AppType string `json:"app_type,omitempty"`

	// A set of URLs that are valid to call back from Auth0 when authenticating users
	// Unique: true
	Callbacks []string `json:"callbacks"`

	// List of audiences for SAML protocol
	// Unique: true
	ClientAliases []string `json:"client_aliases"`

	// client metadata
	ClientMetadata PatchClientsByIDBodyClientMetadata `json:"client_metadata,omitempty"`

	// The secret used to sign tokens for the client
	ClientSecret string `json:"client_secret,omitempty"`

	// <code>true</code> if this client can be used to make cross-origin authentication requests, <code>false</code> otherwise (default: <code>false</code>)
	CrossOriginAuth bool `json:"cross_origin_auth,omitempty"`

	// Url fo the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc string `json:"cross_origin_loc,omitempty"`

	// The content (HTML, CSS, JS) of the custom login page
	CustomLoginPage string `json:"custom_login_page,omitempty"`

	// <code>true</code> if the custom login page is to be used, <code>false</code> otherwise.
	CustomLoginPageOn bool `json:"custom_login_page_on,omitempty"`

	// custom login page preview
	CustomLoginPagePreview string `json:"custom_login_page_preview,omitempty"`

	// Free text description of the purpose of the Client. (Max character length: <code>140</code>)
	Description string `json:"description,omitempty"`

	// encryption key
	EncryptionKey *PatchClientsByIDBodyEncryptionKey `json:"encryption_key,omitempty"`

	// Form template for WS-Federation protocol
	FormTemplate string `json:"form_template,omitempty"`

	// A set of grant types that the client is authorized to use
	// Unique: true
	GrantTypes []string `json:"grant_types"`

	// jwt configuration
	JwtConfiguration *PatchClientsByIDBodyJwtConfiguration `json:"jwt_configuration,omitempty"`

	// The URL of the client logo (recommended size: 150x150)
	LogoURI string `json:"logo_uri,omitempty"`

	// mobile
	Mobile *PatchClientsByIDBodyMobile `json:"mobile,omitempty"`

	// The name of the client. Must contain at least one character. Does not allow '<' or '>'.
	Name string `json:"name,omitempty"`

	// Whether this client will conform to strict OIDC specifications
	OidcConformant *bool `json:"oidc_conformant,omitempty"`

	// <code>true</code> to use Auth0 instead of the IdP to do Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	Sso bool `json:"sso,omitempty"`

	// <code>true</code> to disable Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	SsoDisabled bool `json:"sso_disabled,omitempty"`

	// Defines the requested authentication method for the token endpoint. Possible values are 'none' (public client without a client secret), 'client_secret_post' (client uses HTTP POST parameters) or 'client_secret_basic' (client uses HTTP Basic)
	// Enum: [none client_secret_post client_secret_basic]
	TokenEndpointAuthMethod string `json:"token_endpoint_auth_method,omitempty"`

	// A set of URLs that represents valid web origins for use with web message response mode
	// Unique: true
	WebOrigins []string `json:"web_origins"`
}

// Validate validates this patch clients by id body
func (m *PatchClientsByIDBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedClients(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedLogoutUrls(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedOrigins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCallbacks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGrantTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwtConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenEndpointAuthMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWebOrigins(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchClientsByIDBody) validateAddons(formats strfmt.Registry) error {

	if swag.IsZero(m.Addons) { // not required
		return nil
	}

	if m.Addons != nil {
		if err := m.Addons.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addons")
			}
			return err
		}
	}

	return nil
}

func (m *PatchClientsByIDBody) validateAllowedClients(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedClients) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_clients", "body", m.AllowedClients); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateAllowedLogoutUrls(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedLogoutUrls) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_logout_urls", "body", m.AllowedLogoutUrls); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateAllowedOrigins(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedOrigins) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_origins", "body", m.AllowedOrigins); err != nil {
		return err
	}

	return nil
}

var patchClientsByIdBodyTypeAppTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["native","spa","regular_web","non_interactive","rms","box","cloudbees","concur","dropbox","mscrm","echosign","egnyte","newrelic","office365","salesforce","sentry","sharepoint","slack","springcm","zendesk","zoom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchClientsByIdBodyTypeAppTypePropEnum = append(patchClientsByIdBodyTypeAppTypePropEnum, v)
	}
}

const (

	// PatchClientsByIDBodyAppTypeNative captures enum value "native"
	PatchClientsByIDBodyAppTypeNative string = "native"

	// PatchClientsByIDBodyAppTypeSpa captures enum value "spa"
	PatchClientsByIDBodyAppTypeSpa string = "spa"

	// PatchClientsByIDBodyAppTypeRegularWeb captures enum value "regular_web"
	PatchClientsByIDBodyAppTypeRegularWeb string = "regular_web"

	// PatchClientsByIDBodyAppTypeNonInteractive captures enum value "non_interactive"
	PatchClientsByIDBodyAppTypeNonInteractive string = "non_interactive"

	// PatchClientsByIDBodyAppTypeRms captures enum value "rms"
	PatchClientsByIDBodyAppTypeRms string = "rms"

	// PatchClientsByIDBodyAppTypeBox captures enum value "box"
	PatchClientsByIDBodyAppTypeBox string = "box"

	// PatchClientsByIDBodyAppTypeCloudbees captures enum value "cloudbees"
	PatchClientsByIDBodyAppTypeCloudbees string = "cloudbees"

	// PatchClientsByIDBodyAppTypeConcur captures enum value "concur"
	PatchClientsByIDBodyAppTypeConcur string = "concur"

	// PatchClientsByIDBodyAppTypeDropbox captures enum value "dropbox"
	PatchClientsByIDBodyAppTypeDropbox string = "dropbox"

	// PatchClientsByIDBodyAppTypeMscrm captures enum value "mscrm"
	PatchClientsByIDBodyAppTypeMscrm string = "mscrm"

	// PatchClientsByIDBodyAppTypeEchosign captures enum value "echosign"
	PatchClientsByIDBodyAppTypeEchosign string = "echosign"

	// PatchClientsByIDBodyAppTypeEgnyte captures enum value "egnyte"
	PatchClientsByIDBodyAppTypeEgnyte string = "egnyte"

	// PatchClientsByIDBodyAppTypeNewrelic captures enum value "newrelic"
	PatchClientsByIDBodyAppTypeNewrelic string = "newrelic"

	// PatchClientsByIDBodyAppTypeOffice365 captures enum value "office365"
	PatchClientsByIDBodyAppTypeOffice365 string = "office365"

	// PatchClientsByIDBodyAppTypeSalesforce captures enum value "salesforce"
	PatchClientsByIDBodyAppTypeSalesforce string = "salesforce"

	// PatchClientsByIDBodyAppTypeSentry captures enum value "sentry"
	PatchClientsByIDBodyAppTypeSentry string = "sentry"

	// PatchClientsByIDBodyAppTypeSharepoint captures enum value "sharepoint"
	PatchClientsByIDBodyAppTypeSharepoint string = "sharepoint"

	// PatchClientsByIDBodyAppTypeSLACK captures enum value "slack"
	PatchClientsByIDBodyAppTypeSLACK string = "slack"

	// PatchClientsByIDBodyAppTypeSpringcm captures enum value "springcm"
	PatchClientsByIDBodyAppTypeSpringcm string = "springcm"

	// PatchClientsByIDBodyAppTypeZendesk captures enum value "zendesk"
	PatchClientsByIDBodyAppTypeZendesk string = "zendesk"

	// PatchClientsByIDBodyAppTypeZoom captures enum value "zoom"
	PatchClientsByIDBodyAppTypeZoom string = "zoom"
)

// prop value enum
func (m *PatchClientsByIDBody) validateAppTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, patchClientsByIdBodyTypeAppTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PatchClientsByIDBody) validateAppType(formats strfmt.Registry) error {

	if swag.IsZero(m.AppType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAppTypeEnum("app_type", "body", m.AppType); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateCallbacks(formats strfmt.Registry) error {

	if swag.IsZero(m.Callbacks) { // not required
		return nil
	}

	if err := validate.UniqueItems("callbacks", "body", m.Callbacks); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateClientAliases(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientAliases) { // not required
		return nil
	}

	if err := validate.UniqueItems("client_aliases", "body", m.ClientAliases); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateEncryptionKey(formats strfmt.Registry) error {

	if swag.IsZero(m.EncryptionKey) { // not required
		return nil
	}

	if m.EncryptionKey != nil {
		if err := m.EncryptionKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_key")
			}
			return err
		}
	}

	return nil
}

func (m *PatchClientsByIDBody) validateGrantTypes(formats strfmt.Registry) error {

	if swag.IsZero(m.GrantTypes) { // not required
		return nil
	}

	if err := validate.UniqueItems("grant_types", "body", m.GrantTypes); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateJwtConfiguration(formats strfmt.Registry) error {

	if swag.IsZero(m.JwtConfiguration) { // not required
		return nil
	}

	if m.JwtConfiguration != nil {
		if err := m.JwtConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwt_configuration")
			}
			return err
		}
	}

	return nil
}

func (m *PatchClientsByIDBody) validateMobile(formats strfmt.Registry) error {

	if swag.IsZero(m.Mobile) { // not required
		return nil
	}

	if m.Mobile != nil {
		if err := m.Mobile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile")
			}
			return err
		}
	}

	return nil
}

var patchClientsByIdBodyTypeTokenEndpointAuthMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","client_secret_post","client_secret_basic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		patchClientsByIdBodyTypeTokenEndpointAuthMethodPropEnum = append(patchClientsByIdBodyTypeTokenEndpointAuthMethodPropEnum, v)
	}
}

const (

	// PatchClientsByIDBodyTokenEndpointAuthMethodNone captures enum value "none"
	PatchClientsByIDBodyTokenEndpointAuthMethodNone string = "none"

	// PatchClientsByIDBodyTokenEndpointAuthMethodClientSecretPost captures enum value "client_secret_post"
	PatchClientsByIDBodyTokenEndpointAuthMethodClientSecretPost string = "client_secret_post"

	// PatchClientsByIDBodyTokenEndpointAuthMethodClientSecretBasic captures enum value "client_secret_basic"
	PatchClientsByIDBodyTokenEndpointAuthMethodClientSecretBasic string = "client_secret_basic"
)

// prop value enum
func (m *PatchClientsByIDBody) validateTokenEndpointAuthMethodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, patchClientsByIdBodyTypeTokenEndpointAuthMethodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PatchClientsByIDBody) validateTokenEndpointAuthMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.TokenEndpointAuthMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateTokenEndpointAuthMethodEnum("token_endpoint_auth_method", "body", m.TokenEndpointAuthMethod); err != nil {
		return err
	}

	return nil
}

func (m *PatchClientsByIDBody) validateWebOrigins(formats strfmt.Registry) error {

	if swag.IsZero(m.WebOrigins) { // not required
		return nil
	}

	if err := validate.UniqueItems("web_origins", "body", m.WebOrigins); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchClientsByIDBody) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchClientsByIDBody) UnmarshalBinary(b []byte) error {
	var res PatchClientsByIDBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
