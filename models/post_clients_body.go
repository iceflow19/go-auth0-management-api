// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PostClientsBody post clients body
// swagger:model post_clients_body
type PostClientsBody struct {

	// addons
	Addons *PostClientsBodyAddons `json:"addons,omitempty"`

	// Ids of clients that will be allowed to perform delegation requests. Clients that will be allowed to make delegation request. By default, all your clients will be allowed. This field allows you to specify specific clients
	// Unique: true
	AllowedClients []string `json:"allowed_clients"`

	// A set of URLs that are valid to redirect to after logout from Auth0
	// Unique: true
	AllowedLogoutUrls []string `json:"allowed_logout_urls"`

	// A set of URLs that represents valid origins for CORS
	// Unique: true
	AllowedOrigins []string `json:"allowed_origins"`

	// The type of application this client represents
	// Enum: [native spa regular_web non_interactive rms box cloudbees concur dropbox mscrm echosign egnyte newrelic office365 salesforce sentry sharepoint slack springcm zendesk zoom]
	AppType string `json:"app_type,omitempty"`

	// A set of URLs that are valid to call back from Auth0 when authenticating users
	// Unique: true
	Callbacks []string `json:"callbacks"`

	// List of audiences for SAML protocol
	// Unique: true
	ClientAliases []string `json:"client_aliases"`

	// client metadata
	ClientMetadata PostClientsBodyClientMetadata `json:"client_metadata,omitempty"`

	// <code>true</code> if this client can be used to make cross-origin authentication requests, <code>false</code> otherwise (default: <code>false</code>)
	CrossOriginAuth bool `json:"cross_origin_auth,omitempty"`

	// Url fo the location in your site where the cross origin verification takes place for the cross-origin auth flow when performing Auth in your own domain instead of Auth0 hosted login page.
	CrossOriginLoc string `json:"cross_origin_loc,omitempty"`

	// The content (HTML, CSS, JS) of the custom login page
	CustomLoginPage string `json:"custom_login_page,omitempty"`

	// <code>true</code> if the custom login page is to be used, <code>false</code> otherwise. Defaults to <code>true</code>
	CustomLoginPageOn bool `json:"custom_login_page_on,omitempty"`

	// custom login page preview
	CustomLoginPagePreview string `json:"custom_login_page_preview,omitempty"`

	// Free text description of the purpose of the Client. (Max character length: <code>140</code>)
	Description string `json:"description,omitempty"`

	// encryption key
	EncryptionKey *PostClientsBodyEncryptionKey `json:"encryption_key,omitempty"`

	// Form template for WS-Federation protocol
	FormTemplate string `json:"form_template,omitempty"`

	// A set of grant types that the client is authorized to use
	// Unique: true
	GrantTypes []string `json:"grant_types"`

	// <code>true</code> if the client is a heroku application, <code>false</code> otherwise
	IsHerokuApp bool `json:"is_heroku_app,omitempty"`

	// jwt configuration
	JwtConfiguration *PostClientsBodyJwtConfiguration `json:"jwt_configuration,omitempty"`

	// The URL of the client logo (recommended size: 150x150)
	LogoURI string `json:"logo_uri,omitempty"`

	// mobile
	Mobile *PostClientsBodyMobile `json:"mobile,omitempty"`

	// The name of the client. Must contain at least one character. Does not allow '<' or '>'
	// Required: true
	Name *string `json:"name"`

	// Whether this client will conform to strict OIDC specifications
	OidcConformant *bool `json:"oidc_conformant,omitempty"`

	// <code>true</code> to use Auth0 instead of the IdP to do Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	Sso bool `json:"sso,omitempty"`

	// <code>true</code> to disable Single Sign On, <code>false</code> otherwise (default: <code>false</code>)
	SsoDisabled bool `json:"sso_disabled,omitempty"`

	// Defines the requested authentication method for the token endpoint. Possible values are 'none' (public client without a client secret), 'client_secret_post' (client uses HTTP POST parameters) or 'client_secret_basic' (client uses HTTP Basic)
	// Enum: [none client_secret_post client_secret_basic]
	TokenEndpointAuthMethod string `json:"token_endpoint_auth_method,omitempty"`

	// A set of URLs that represents valid web origins for use with web message response mode
	// Unique: true
	WebOrigins []string `json:"web_origins"`
}

// Validate validates this post clients body
func (m *PostClientsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddons(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedClients(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedLogoutUrls(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowedOrigins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCallbacks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncryptionKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGrantTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJwtConfiguration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenEndpointAuthMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWebOrigins(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PostClientsBody) validateAddons(formats strfmt.Registry) error {

	if swag.IsZero(m.Addons) { // not required
		return nil
	}

	if m.Addons != nil {
		if err := m.Addons.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addons")
			}
			return err
		}
	}

	return nil
}

func (m *PostClientsBody) validateAllowedClients(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedClients) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_clients", "body", m.AllowedClients); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateAllowedLogoutUrls(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedLogoutUrls) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_logout_urls", "body", m.AllowedLogoutUrls); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateAllowedOrigins(formats strfmt.Registry) error {

	if swag.IsZero(m.AllowedOrigins) { // not required
		return nil
	}

	if err := validate.UniqueItems("allowed_origins", "body", m.AllowedOrigins); err != nil {
		return err
	}

	return nil
}

var postClientsBodyTypeAppTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["native","spa","regular_web","non_interactive","rms","box","cloudbees","concur","dropbox","mscrm","echosign","egnyte","newrelic","office365","salesforce","sentry","sharepoint","slack","springcm","zendesk","zoom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postClientsBodyTypeAppTypePropEnum = append(postClientsBodyTypeAppTypePropEnum, v)
	}
}

const (

	// PostClientsBodyAppTypeNative captures enum value "native"
	PostClientsBodyAppTypeNative string = "native"

	// PostClientsBodyAppTypeSpa captures enum value "spa"
	PostClientsBodyAppTypeSpa string = "spa"

	// PostClientsBodyAppTypeRegularWeb captures enum value "regular_web"
	PostClientsBodyAppTypeRegularWeb string = "regular_web"

	// PostClientsBodyAppTypeNonInteractive captures enum value "non_interactive"
	PostClientsBodyAppTypeNonInteractive string = "non_interactive"

	// PostClientsBodyAppTypeRms captures enum value "rms"
	PostClientsBodyAppTypeRms string = "rms"

	// PostClientsBodyAppTypeBox captures enum value "box"
	PostClientsBodyAppTypeBox string = "box"

	// PostClientsBodyAppTypeCloudbees captures enum value "cloudbees"
	PostClientsBodyAppTypeCloudbees string = "cloudbees"

	// PostClientsBodyAppTypeConcur captures enum value "concur"
	PostClientsBodyAppTypeConcur string = "concur"

	// PostClientsBodyAppTypeDropbox captures enum value "dropbox"
	PostClientsBodyAppTypeDropbox string = "dropbox"

	// PostClientsBodyAppTypeMscrm captures enum value "mscrm"
	PostClientsBodyAppTypeMscrm string = "mscrm"

	// PostClientsBodyAppTypeEchosign captures enum value "echosign"
	PostClientsBodyAppTypeEchosign string = "echosign"

	// PostClientsBodyAppTypeEgnyte captures enum value "egnyte"
	PostClientsBodyAppTypeEgnyte string = "egnyte"

	// PostClientsBodyAppTypeNewrelic captures enum value "newrelic"
	PostClientsBodyAppTypeNewrelic string = "newrelic"

	// PostClientsBodyAppTypeOffice365 captures enum value "office365"
	PostClientsBodyAppTypeOffice365 string = "office365"

	// PostClientsBodyAppTypeSalesforce captures enum value "salesforce"
	PostClientsBodyAppTypeSalesforce string = "salesforce"

	// PostClientsBodyAppTypeSentry captures enum value "sentry"
	PostClientsBodyAppTypeSentry string = "sentry"

	// PostClientsBodyAppTypeSharepoint captures enum value "sharepoint"
	PostClientsBodyAppTypeSharepoint string = "sharepoint"

	// PostClientsBodyAppTypeSLACK captures enum value "slack"
	PostClientsBodyAppTypeSLACK string = "slack"

	// PostClientsBodyAppTypeSpringcm captures enum value "springcm"
	PostClientsBodyAppTypeSpringcm string = "springcm"

	// PostClientsBodyAppTypeZendesk captures enum value "zendesk"
	PostClientsBodyAppTypeZendesk string = "zendesk"

	// PostClientsBodyAppTypeZoom captures enum value "zoom"
	PostClientsBodyAppTypeZoom string = "zoom"
)

// prop value enum
func (m *PostClientsBody) validateAppTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, postClientsBodyTypeAppTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PostClientsBody) validateAppType(formats strfmt.Registry) error {

	if swag.IsZero(m.AppType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAppTypeEnum("app_type", "body", m.AppType); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateCallbacks(formats strfmt.Registry) error {

	if swag.IsZero(m.Callbacks) { // not required
		return nil
	}

	if err := validate.UniqueItems("callbacks", "body", m.Callbacks); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateClientAliases(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientAliases) { // not required
		return nil
	}

	if err := validate.UniqueItems("client_aliases", "body", m.ClientAliases); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateEncryptionKey(formats strfmt.Registry) error {

	if swag.IsZero(m.EncryptionKey) { // not required
		return nil
	}

	if m.EncryptionKey != nil {
		if err := m.EncryptionKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("encryption_key")
			}
			return err
		}
	}

	return nil
}

func (m *PostClientsBody) validateGrantTypes(formats strfmt.Registry) error {

	if swag.IsZero(m.GrantTypes) { // not required
		return nil
	}

	if err := validate.UniqueItems("grant_types", "body", m.GrantTypes); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateJwtConfiguration(formats strfmt.Registry) error {

	if swag.IsZero(m.JwtConfiguration) { // not required
		return nil
	}

	if m.JwtConfiguration != nil {
		if err := m.JwtConfiguration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jwt_configuration")
			}
			return err
		}
	}

	return nil
}

func (m *PostClientsBody) validateMobile(formats strfmt.Registry) error {

	if swag.IsZero(m.Mobile) { // not required
		return nil
	}

	if m.Mobile != nil {
		if err := m.Mobile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mobile")
			}
			return err
		}
	}

	return nil
}

func (m *PostClientsBody) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var postClientsBodyTypeTokenEndpointAuthMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","client_secret_post","client_secret_basic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		postClientsBodyTypeTokenEndpointAuthMethodPropEnum = append(postClientsBodyTypeTokenEndpointAuthMethodPropEnum, v)
	}
}

const (

	// PostClientsBodyTokenEndpointAuthMethodNone captures enum value "none"
	PostClientsBodyTokenEndpointAuthMethodNone string = "none"

	// PostClientsBodyTokenEndpointAuthMethodClientSecretPost captures enum value "client_secret_post"
	PostClientsBodyTokenEndpointAuthMethodClientSecretPost string = "client_secret_post"

	// PostClientsBodyTokenEndpointAuthMethodClientSecretBasic captures enum value "client_secret_basic"
	PostClientsBodyTokenEndpointAuthMethodClientSecretBasic string = "client_secret_basic"
)

// prop value enum
func (m *PostClientsBody) validateTokenEndpointAuthMethodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, postClientsBodyTypeTokenEndpointAuthMethodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *PostClientsBody) validateTokenEndpointAuthMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.TokenEndpointAuthMethod) { // not required
		return nil
	}

	// value enum
	if err := m.validateTokenEndpointAuthMethodEnum("token_endpoint_auth_method", "body", m.TokenEndpointAuthMethod); err != nil {
		return err
	}

	return nil
}

func (m *PostClientsBody) validateWebOrigins(formats strfmt.Registry) error {

	if swag.IsZero(m.WebOrigins) { // not required
		return nil
	}

	if err := validate.UniqueItems("web_origins", "body", m.WebOrigins); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PostClientsBody) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PostClientsBody) UnmarshalBinary(b []byte) error {
	var res PostClientsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
