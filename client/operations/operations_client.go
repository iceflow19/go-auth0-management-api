// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteClientGrantsByID deletes a client grant
*/
func (a *Client) DeleteClientGrantsByID(params *DeleteClientGrantsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteClientGrantsByIDOK, *DeleteClientGrantsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClientGrantsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_client-grants_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/client-grants/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClientGrantsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteClientGrantsByIDOK:
		return value, nil, nil
	case *DeleteClientGrantsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteClientsByID deletes a client

Deletes a client and all its related assets (like rules, connections, etc) given its id.
*/
func (a *Client) DeleteClientsByID(params *DeleteClientsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteClientsByIDOK, *DeleteClientsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClientsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_clients_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/clients/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClientsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteClientsByIDOK:
		return value, nil, nil
	case *DeleteClientsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteConnectionsByID deletes a connection

Deletes a connection and all its users.

*/
func (a *Client) DeleteConnectionsByID(params *DeleteConnectionsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteConnectionsByIDOK, *DeleteConnectionsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConnectionsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_connections_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/connections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConnectionsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteConnectionsByIDOK:
		return value, nil, nil
	case *DeleteConnectionsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteCustomDomainsByID deletes custom domain configuration

Deletes a custom domain by its <code>ID</code>. We will stop serving requests for this domain.

*/
func (a *Client) DeleteCustomDomainsByID(params *DeleteCustomDomainsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCustomDomainsByIDOK, *DeleteCustomDomainsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCustomDomainsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_custom-domains_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/custom-domains/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteCustomDomainsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteCustomDomainsByIDOK:
		return value, nil, nil
	case *DeleteCustomDomainsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteDeviceCredentialsByID deletes a device credential

Manage the devices that are recognized and authenticated. You can use the device-credentials endpoint using Basic authentication with username and password from a database connection<br />The Authorization header should be <code>Authorization: Basic base64("{db_conn_name}\{user}:{password}")</code>

Please note that Device Credentials endpoints are designed for ad hoc administrative use only.
*/
func (a *Client) DeleteDeviceCredentialsByID(params *DeleteDeviceCredentialsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteDeviceCredentialsByIDOK, *DeleteDeviceCredentialsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDeviceCredentialsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_device-credentials_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/device-credentials/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteDeviceCredentialsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteDeviceCredentialsByIDOK:
		return value, nil, nil
	case *DeleteDeviceCredentialsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteEnrollmentsByID deletes a guardian enrollment

Deletes an enrollment. Useful when you want to force the user to re-enroll with Guardian.
*/
func (a *Client) DeleteEnrollmentsByID(params *DeleteEnrollmentsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteEnrollmentsByIDOK, *DeleteEnrollmentsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteEnrollmentsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_enrollments_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/guardian/enrollments/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteEnrollmentsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteEnrollmentsByIDOK:
		return value, nil, nil
	case *DeleteEnrollmentsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteGrantsByID deletes a grant
*/
func (a *Client) DeleteGrantsByID(params *DeleteGrantsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteGrantsByIDOK, *DeleteGrantsByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGrantsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_grants_by_id?",
		Method:             "DELETE",
		PathPattern:        "/api/v2/grants/{id",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteGrantsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteGrantsByIDOK:
		return value, nil, nil
	case *DeleteGrantsByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteMultifactorByProvider deletes a user s multifactor provider

This endpoint can be used to delete the multifactor provider settings for a particular user. This will force user to re-configure the multifactor provider.

<a href="https://auth0.com/docs/multifactor-authentication">Click here to learn more about Multifactor Authentication</a>


*/
func (a *Client) DeleteMultifactorByProvider(params *DeleteMultifactorByProviderParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteMultifactorByProviderOK, *DeleteMultifactorByProviderNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMultifactorByProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_multifactor_by_provider",
		Method:             "DELETE",
		PathPattern:        "/api/v2/users/{id}/multifactor/{provider}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteMultifactorByProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteMultifactorByProviderOK:
		return value, nil, nil
	case *DeleteMultifactorByProviderNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteProvider deletes the email provider

<strong>USE WITH CAUTION</strong>
*/
func (a *Client) DeleteProvider(params *DeleteProviderParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_provider",
		Method:             "DELETE",
		PathPattern:        "/api/v2/emails/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteProviderOK), nil

}

/*
DeleteResourceServersByID deletes a resource server
*/
func (a *Client) DeleteResourceServersByID(params *DeleteResourceServersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteResourceServersByIDOK, *DeleteResourceServersByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteResourceServersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_resource-servers_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/resource-servers/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteResourceServersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteResourceServersByIDOK:
		return value, nil, nil
	case *DeleteResourceServersByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteRulesConfigsByKey removes the rules config for a given key

Config keys must be of the format <code>^[A-Za-z0-9_\-@*+:]*$</code>
*/
func (a *Client) DeleteRulesConfigsByKey(params *DeleteRulesConfigsByKeyParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRulesConfigsByKeyOK, *DeleteRulesConfigsByKeyNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRulesConfigsByKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_rules-configs_by_key",
		Method:             "DELETE",
		PathPattern:        "/api/v2/rules-configs/{key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRulesConfigsByKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRulesConfigsByKeyOK:
		return value, nil, nil
	case *DeleteRulesConfigsByKeyNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteRulesByID deletes a rule

To be used to delete a rule.

<a href="https://auth0.com/docs/rules">Learn more about rules</a>
*/
func (a *Client) DeleteRulesByID(params *DeleteRulesByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRulesByIDOK, *DeleteRulesByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRulesByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_rules_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRulesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRulesByIDOK:
		return value, nil, nil
	case *DeleteRulesByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteUserBlocks unblocks by identifier

This endpoint can be used to unblock a given key that was blocked due to an excessive amount of incorrectly provided credentials.
*/
func (a *Client) DeleteUserBlocks(params *DeleteUserBlocksParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserBlocksOK, *DeleteUserBlocksNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserBlocksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_user-blocks",
		Method:             "DELETE",
		PathPattern:        "/api/v2/user-blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserBlocksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteUserBlocksOK:
		return value, nil, nil
	case *DeleteUserBlocksNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteUserBlocksByID unblocks a user

This endpoint can be used to unblock a user that was blocked due to an excessive amount of incorrectly provided credentials.

This endpoint does not unblock users that were blocked by admins. <a href="https://auth0.com/docs/user-profile#block-and-unblock-a-user">Click here</a> for more information on how to unblock a user that was blocked by an admin.
*/
func (a *Client) DeleteUserBlocksByID(params *DeleteUserBlocksByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserBlocksByIDOK, *DeleteUserBlocksByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserBlocksByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_user-blocks_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/user-blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserBlocksByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteUserBlocksByIDOK:
		return value, nil, nil
	case *DeleteUserBlocksByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteUserIdentityByUserID unlinks a user identity

Unlinks an identity from the target user, and it becomes a separated user again.

*/
func (a *Client) DeleteUserIdentityByUserID(params *DeleteUserIdentityByUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUserIdentityByUserIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUserIdentityByUserIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_user_identity_by_user_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/users/{id}/identities/{provider}/{user_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUserIdentityByUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteUserIdentityByUserIDOK), nil

}

/*
DeleteUsersByEmail deletes a connection user

Deletes a specified connection user by its email (you cannot delete all users from specific connection). Currently, only Database Connections are supported.

*/
func (a *Client) DeleteUsersByEmail(params *DeleteUsersByEmailParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUsersByEmailOK, *DeleteUsersByEmailNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUsersByEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_users_by_email",
		Method:             "DELETE",
		PathPattern:        "/api/v2/connections/{id}/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUsersByEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteUsersByEmailOK:
		return value, nil, nil
	case *DeleteUsersByEmailNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteUsersByID deletes a user

This endpoint can be used to delete a single user based on the <code>id</code>.
*/
func (a *Client) DeleteUsersByID(params *DeleteUsersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUsersByIDOK, *DeleteUsersByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUsersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "delete_users_by_id",
		Method:             "DELETE",
		PathPattern:        "/api/v2/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteUsersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteUsersByIDOK:
		return value, nil, nil
	case *DeleteUsersByIDNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetActiveUsers gets active users count

The amount of active users
*/
func (a *Client) GetActiveUsers(params *GetActiveUsersParams, authInfo runtime.ClientAuthInfoWriter) (*GetActiveUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActiveUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_active-users",
		Method:             "GET",
		PathPattern:        "/api/v2/stats/active-users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActiveUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetActiveUsersOK), nil

}

/*
GetClientGrants gets all client grants

Manage your <a href='https://auth0.com/docs/api-auth/grant/client-credentials'>Client Grants</a> (also called Client Credentials Grants). Using Client Grants, your Client can request an Auth0 access token using its credentials (a Client ID and a Client Secret). The access token then represents your Client during API calls.

Refer to <a href='https://auth0.com/docs/api-auth/config/using-the-management-api'>Using the Management API for Setting Up a Client Credentials Grant Scenario</a> for additional information.



*/
func (a *Client) GetClientGrants(params *GetClientGrantsParams, authInfo runtime.ClientAuthInfoWriter) (*GetClientGrantsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientGrantsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_client-grants",
		Method:             "GET",
		PathPattern:        "/api/v2/client-grants",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClientGrantsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClientGrantsOK), nil

}

/*
GetClients gets all clients

Retrieves a list of all client applications. Accepts a list of fields to include or exclude.

<strong>Important:</strong> The <code>client_secret</code> and <code>encryption_key</code> attributes can only be retrieved with the <code>read:client_keys</code> scope.

*/
func (a *Client) GetClients(params *GetClientsParams, authInfo runtime.ClientAuthInfoWriter) (*GetClientsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_clients",
		Method:             "GET",
		PathPattern:        "/api/v2/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClientsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClientsOK), nil

}

/*
GetClientsByID gets a client

Retrieves a client by its id.

<strong>Important:</strong> The <code>client_secret</code> <code>encryption_key</code> and <code>signing_keys</code> attributes can only be retrieved with the <code>read:client_keys</code> scope.

*/
func (a *Client) GetClientsByID(params *GetClientsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetClientsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClientsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_clients_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/clients/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClientsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClientsByIDOK), nil

}

/*
GetConnections gets all connections

Retrieves every connection matching the specified strategy. All connections are retrieved if no strategy is being specified. Accepts a list of fields to include or exclude in the resulting list of connection objects.

*/
func (a *Client) GetConnections(params *GetConnectionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetConnectionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConnectionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_connections",
		Method:             "GET",
		PathPattern:        "/api/v2/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConnectionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConnectionsOK), nil

}

/*
GetConnectionsByID gets a connection

Retrieves a connection by its <code>ID</code>.

*/
func (a *Client) GetConnectionsByID(params *GetConnectionsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetConnectionsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConnectionsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_connections_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/connections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConnectionsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConnectionsByIDOK), nil

}

/*
GetCustomDomains gets custom domains configurations

Retrieves the status of every custom domain.

*/
func (a *Client) GetCustomDomains(params *GetCustomDomainsParams, authInfo runtime.ClientAuthInfoWriter) (*GetCustomDomainsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomDomainsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_custom-domains",
		Method:             "GET",
		PathPattern:        "/api/v2/custom-domains",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCustomDomainsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCustomDomainsOK), nil

}

/*
GetCustomDomainsByID gets custom domain configuration

Retrieves a custom domain status by its <code>ID</code>.

*/
func (a *Client) GetCustomDomainsByID(params *GetCustomDomainsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetCustomDomainsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCustomDomainsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_custom-domains_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/custom-domains/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCustomDomainsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCustomDomainsByIDOK), nil

}

/*
GetDaily gets daily stats

Retrieves the number of logins that occurred in the entered date range.
*/
func (a *Client) GetDaily(params *GetDailyParams, authInfo runtime.ClientAuthInfoWriter) (*GetDailyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDailyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_daily",
		Method:             "GET",
		PathPattern:        "/api/v2/stats/daily",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDailyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDailyOK), nil

}

/*
GetDeviceCredentials lists device credentials

Manage the devices that are recognized and authenticated. You can use the device-credentials endpoint using Basic authentication with username and password from a database connection<br />The Authorization header should be <code>Authorization: Basic base64("{db_conn_name}\{user}:{password}")</code>

Please note that Device Credentials endpoints are designed for ad hoc administrative use only.
*/
func (a *Client) GetDeviceCredentials(params *GetDeviceCredentialsParams, authInfo runtime.ClientAuthInfoWriter) (*GetDeviceCredentialsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDeviceCredentialsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_device-credentials",
		Method:             "GET",
		PathPattern:        "/api/v2/device-credentials",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetDeviceCredentialsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDeviceCredentialsOK), nil

}

/*
GetEmailTemplatesByTemplateName gets an email template
*/
func (a *Client) GetEmailTemplatesByTemplateName(params *GetEmailTemplatesByTemplateNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetEmailTemplatesByTemplateNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEmailTemplatesByTemplateNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_email-templates_by_templateName",
		Method:             "GET",
		PathPattern:        "/api/v2/email-templates/{templateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEmailTemplatesByTemplateNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEmailTemplatesByTemplateNameOK), nil

}

/*
GetEnrollments gets a list of guardian enrollments

Retrieves all Guardian enrollments.

<a href="https://auth0.com/docs/multifactor-authentication/guardian">Click here to learn more about Guardian</a>
*/
func (a *Client) GetEnrollments(params *GetEnrollmentsParams, authInfo runtime.ClientAuthInfoWriter) (*GetEnrollmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEnrollmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_enrollments",
		Method:             "GET",
		PathPattern:        "/api/v2/users/{id}/enrollments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEnrollmentsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEnrollmentsOK), nil

}

/*
GetEnrollmentsByID gets a guardian enrollment

Retrieves an enrollment. Useful to check its type and related metadata. Note that phone number data is partially obfuscated.
*/
func (a *Client) GetEnrollmentsByID(params *GetEnrollmentsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetEnrollmentsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEnrollmentsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_enrollments_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/guardian/enrollments/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEnrollmentsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEnrollmentsByIDOK), nil

}

/*
GetErrors gets failed job error details

Use this endpoint to retrieve error details based on the id of the job. See below for possible responses.
*/
func (a *Client) GetErrors(params *GetErrorsParams, authInfo runtime.ClientAuthInfoWriter) (*GetErrorsOK, *GetErrorsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetErrorsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_errors",
		Method:             "GET",
		PathPattern:        "/api/v2/jobs/{id}/errors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetErrorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetErrorsOK:
		return value, nil, nil
	case *GetErrorsNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetFactors gets a list of factors and statuses

Retrieves all factors. Useful to check factor enablement and trial status.
*/
func (a *Client) GetFactors(params *GetFactorsParams, authInfo runtime.ClientAuthInfoWriter) (*GetFactorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFactorsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_factors",
		Method:             "GET",
		PathPattern:        "/api/v2/guardian/factors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFactorsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFactorsOK), nil

}

/*
GetGrants gets grants

Manage the <a href="https://auth0.com/docs/api-auth/which-oauth-flow-to-use">grants</a> associated with your account.

*/
func (a *Client) GetGrants(params *GetGrantsParams, authInfo runtime.ClientAuthInfoWriter) (*GetGrantsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGrantsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_grants",
		Method:             "GET",
		PathPattern:        "/api/v2/grants",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetGrantsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGrantsOK), nil

}

/*
GetJobsByID gets a job

Retrieves a job. Useful to check its status.
*/
func (a *Client) GetJobsByID(params *GetJobsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetJobsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetJobsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_jobs_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/jobs/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetJobsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetJobsByIDOK), nil

}

/*
GetLogs searches log events

Retrieves log entries that match the specified search criteria (or list all entries if no criteria is used).<br/>You can search with a criteria using the <code>q</code> parameter or you can search by a specific log ID (search by checkpoint):<br/><br/><h5>The search by criteria can use the following parameters:</h5><ul> <li><b>q:</b> Search Criteria using <a href="https://auth0.com/docs/users/search/v2/query-syntax">Query String Syntax</a></li><li><b>page:</b> The page number. Zero based</li><li><b>per_page:</b> The amount of entries per page</li><li><b>sort:</b> The field to use for sorting. Use <code>field:order</code>, where order is <code>1</code> for ascending and <code>-1</code> for descending. For example <code>date:-1</code></li><li><b>fields:</b> A comma separated list of fields to include or exclude (depending on include_fields) from the result, empty to retrieve all fields</li><li><b>include_fields:</b> <code>true</code> if the fields specified are to be included in the result, <code>false</code> otherwise. Defaults to <code>true</code></li><li><b>include_totals:</b> <code>true</code> if a query summary must be included in the result, false otherwise. Default <code>false</code>.</li></ul><h5>The search by checkpoint use the following parameters:</h5><ul> <li><b>from:</b> Log Event Id to start retrieving logs. You can limit the amount of logs using the <code>take</code> parameter. If you use <code>from</code> at the same time as <code>q</code>, <code>from</code> takes precedence and <code>q</code> is ignored.</li><li><b>take:</b> The total amount of entries to retrieve when using the <code>from</code> parameter.</li></ul><p><strong>Important:</strong> When fetching logs by checkpoint, the order by date is not guaranteed</p>
<h5>Event acronym mapping</h5><ul><li>s: Success Login </li><li>ssa: Success Silent Auth</li><li>fsa: Failed Silent Auth</li><li>seacft: Success Exchange (Authorization Code for Access Token)</li><li>feacft: Failed Exchange (Authorization Code for Access Token)</li><li>seccft: Success Exchange (Client Credentials for Access Token)</li><li>feccft: Failed Exchange (Client Credentials for Access Token)</li><li>sepft: Success Exchange (Password for Access Token)</li><li>fepft: Failed Exchange (Password for Access Token)</li><li>f: Failed Login </li><li>w: Warnings During Login </li><li>du: Deleted User </li><li>fu: Failed Login (invalid email/username) </li><li>fp: Failed Login (wrong password) </li><li>fc: Failed by Connector </li><li>fco: Failed by CORS </li><li>con: Connector Online </li><li>coff: Connector Offline </li><li>fcpro: Failed Connector Provisioning </li><li>ss: Success Signup </li><li>fs: Failed Signup </li><li>cs: Code Sent </li><li>cls: Code/Link Sent </li><li>sv: Success Verification Email </li><li>fv: Failed Verification Email </li><li>scp: Success Change Password </li><li>fcp: Failed Change Password </li><li>sce: Success Change Email </li><li>fce: Failed Change Email </li><li>scu: Success Change Username </li><li>fcu: Failed Change Username </li><li>scpn: Success Change Phone Number </li><li>fcpn: Failed Change Phone Number </li><li>svr: Success Verification Email Request </li><li>fvr: Failed Verification Email Request </li><li>scpr: Success Change Password Request </li><li>fcpr: Failed Change Password Request </li><li>fn: Failed Sending Notification </li><li>sapi: API Operation </li><li>fapi: Failed API Operation </li><li>limit_wc: Blocked Account </li><li>limit_mu: Blocked IP Address </li><li>limit_ui: Too Many Calls to /userinfo </li><li>api_limit: Rate Limit On API </li><li>sdu: Successful User Deletion </li><li>fdu: Failed User Deletion </li><li>slo: Success Logout</li><li>flo: Failed Logout</li><li>sd: Success Delegation</li><li>fd: Failed Delegation</li><li>fcoa: Failed Cross Origin Authentication</li><li>scoa: Success Cross Origin Authentication</li></ul>
<h5>List of fields that can be used in fields and sort</h5><ul><li>date: The moment when the event occured.</li><li>connection: The connection related to the event.</li><li>client_id: The client id related to the event</li><li>client_name: The name of the client related to the event.</li><li>ip: The IP address from where the request that caused the log entry originated.</li><li>user_id: The user id related to the event.</li><li>user_name: The user name related to the event.</li><li>description: The description of the event.</li><li>user_agent: The user agent that is related to the event.</li><li>type: The event type. Refer to the event acronym mappings above for a list of possible event types.</li><li>details: The details object of the event.</li><li>strategy: The connection strategy related to the event.</li><li>strategy_type: The connection strategy type related to the event.</li></ul>
*/
func (a *Client) GetLogs(params *GetLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_logs",
		Method:             "GET",
		PathPattern:        "/api/v2/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogsOK), nil

}

/*
GetLogsByID gets a log event by id

Retrieves the data related to the log entry identified by id. This returns a single log entry representation as specified in the schema.
*/
func (a *Client) GetLogsByID(params *GetLogsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_logs_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/logs/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogsByIDOK), nil

}

/*
GetLogsByUser gets user s log events

Retrieve every log event for a specific user id<br/><h5>Event acronym mapping</h5><ul><li>s: Success Login </li><li>ssa: Success Silent Auth</li><li>fsa: Failed Silent Auth</li><li>seacft: Success Exchange (Authorization Code for Access Token)</li><li>feacft: Failed Exchange (Authorization Code for Access Token)</li><li>seccft: Success Exchange (Client Credentials for Access Token)</li><li>feccft: Failed Exchange (Client Credentials for Access Token)</li><li>sepft: Success Exchange (Password for Access Token)</li><li>fepft: Failed Exchange (Password for Access Token)</li><li>f: Failed Login </li><li>w: Warnings During Login </li><li>du: Deleted User </li><li>fu: Failed Login (invalid email/username) </li><li>fp: Failed Login (wrong password) </li><li>fc: Failed by Connector </li><li>fco: Failed by CORS </li><li>con: Connector Online </li><li>coff: Connector Offline </li><li>fcpro: Failed Connector Provisioning </li><li>ss: Success Signup </li><li>fs: Failed Signup </li><li>cs: Code Sent </li><li>cls: Code/Link Sent </li><li>sv: Success Verification Email </li><li>fv: Failed Verification Email </li><li>scp: Success Change Password </li><li>fcp: Failed Change Password </li><li>sce: Success Change Email </li><li>fce: Failed Change Email </li><li>scu: Success Change Username </li><li>fcu: Failed Change Username </li><li>scpn: Success Change Phone Number </li><li>fcpn: Failed Change Phone Number </li><li>svr: Success Verification Email Request </li><li>fvr: Failed Verification Email Request </li><li>scpr: Success Change Password Request </li><li>fcpr: Failed Change Password Request </li><li>fn: Failed Sending Notification </li><li>sapi: API Operation </li><li>fapi: Failed API Operation </li><li>limit_wc: Blocked Account </li><li>limit_mu: Blocked IP Address </li><li>limit_ui: Too Many Calls to /userinfo </li><li>api_limit: Rate Limit On API </li><li>sdu: Successful User Deletion </li><li>fdu: Failed User Deletion </li><li>slo: Success Logout</li><li>flo: Failed Logout</li><li>sd: Success Delegation</li><li>fd: Failed Delegation</li><li>fcoa: Failed Cross Origin Authentication</li><li>scoa: Success Cross Origin Authentication</li></ul>
<h5>List of fields that can be used in fields and sort</h5><ul><li>date: The moment when the event occured.</li><li>connection: The connection related to the event.</li><li>client_id: The client id related to the event</li><li>client_name: The name of the client related to the event.</li><li>ip: The IP address from where the request that caused the log entry originated.</li><li>user_id: The user id related to the event.</li><li>user_name: The user name related to the event.</li><li>description: The description of the event.</li><li>user_agent: The user agent that is related to the event.</li><li>type: The event type. Refer to the event acronym mappings above for a list of possible event types.</li><li>details: The details object of the event.</li><li>strategy: The connection strategy related to the event.</li><li>strategy_type: The connection strategy type related to the event.</li></ul>
*/
func (a *Client) GetLogsByUser(params *GetLogsByUserParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogsByUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogsByUserParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_logs_by_user",
		Method:             "GET",
		PathPattern:        "/api/v2/users/{user_id}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetLogsByUserReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogsByUserOK), nil

}

/*
GetProvider gets the email provider

This endpoint can be used to retrieve the name of the email provider.
*/
func (a *Client) GetProvider(params *GetProviderParams, authInfo runtime.ClientAuthInfoWriter) (*GetProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_provider",
		Method:             "GET",
		PathPattern:        "/api/v2/emails/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProviderOK), nil

}

/*
GetResourceServers gets all resource servers

Manage your Resource Servers. These host protected resources that you can access by interfacing with its <a href="https://auth0.com/docs/apis">APIs</a>.

*/
func (a *Client) GetResourceServers(params *GetResourceServersParams, authInfo runtime.ClientAuthInfoWriter) (*GetResourceServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResourceServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_resource-servers",
		Method:             "GET",
		PathPattern:        "/api/v2/resource-servers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetResourceServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetResourceServersOK), nil

}

/*
GetResourceServersByID gets a resource server by its id or audience
*/
func (a *Client) GetResourceServersByID(params *GetResourceServersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetResourceServersByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResourceServersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_resource-servers_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/resource-servers/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetResourceServersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetResourceServersByIDOK), nil

}

/*
GetResults gets results of a job
*/
func (a *Client) GetResults(params *GetResultsParams, authInfo runtime.ClientAuthInfoWriter) (*GetResultsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResultsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_results",
		Method:             "GET",
		PathPattern:        "/api/v2/jobs/{job_id}/results",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetResultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetResultsOK), nil

}

/*
GetRules gets all rules

Retrieves a list of all rules. Accepts a list of fields to include or exclude.<br/>
The <code>enabled</code> parameter can be specified to get enabled or disabled rules.
The rule's stage of executing could be set to the following values <code>login_success</code>, <code>login_failure</code> or <code>pre_authorize</code>

<a href="https://auth0.com/docs/rules">Learn more about rules</a>
*/
func (a *Client) GetRules(params *GetRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_rules",
		Method:             "GET",
		PathPattern:        "/api/v2/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRulesOK), nil

}

/*
GetRulesConfigs lists the config variable keys for rules

Returns only rules config variable keys.  For security, config variable values cannot be retrieved outside rule execution
*/
func (a *Client) GetRulesConfigs(params *GetRulesConfigsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRulesConfigsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRulesConfigsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_rules-configs",
		Method:             "GET",
		PathPattern:        "/api/v2/rules-configs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRulesConfigsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRulesConfigsOK), nil

}

/*
GetRulesByID gets a rule

Retrieves a rule by its ID. Accepts a list of fields to include or exclude in the result.

<a href="https://auth0.com/docs/rules">Learn more about rules</a>
*/
func (a *Client) GetRulesByID(params *GetRulesByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRulesByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRulesByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_rules_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRulesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRulesByIDOK), nil

}

/*
GetSettings gets tenant settings

Use this endpoint to retrieve various settings for a tenant.
*/
func (a *Client) GetSettings(params *GetSettingsParams, authInfo runtime.ClientAuthInfoWriter) (*GetSettingsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSettingsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_settings",
		Method:             "GET",
		PathPattern:        "/api/v2/tenants/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSettingsOK), nil

}

/*
GetSns gets guardian s n s factor provider configuration

Returns provider configuration for AWS SNS.

Learn more about <a href="https://auth0.com/docs/multifactor-authentication/developer/sns-configuration">Configuring Amazon SNS.</a>
*/
func (a *Client) GetSns(params *GetSnsParams, authInfo runtime.ClientAuthInfoWriter) (*GetSnsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSnsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_sns",
		Method:             "GET",
		PathPattern:        "/api/v2/guardian/factors/push-notification/providers/sns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSnsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSnsOK), nil

}

/*
GetTemplates gets enrollment and verification templates

Retrieves enrollment and verification templates. You can use this to check the current values for your templates.
*/
func (a *Client) GetTemplates(params *GetTemplatesParams, authInfo runtime.ClientAuthInfoWriter) (*GetTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTemplatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_templates",
		Method:             "GET",
		PathPattern:        "/api/v2/guardian/factors/sms/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTemplatesOK), nil

}

/*
GetTokens gets all blacklisted tokens

Retrieves the <code>jti</code> and <code>aud</code> of all tokens that are blacklisted.

The <a href="https://auth0.com/docs/jwt">JWT spec</a> provides the <code>jti</code> field as a way to prevent replay attacks. Though Auth0 tokens do not currently return a <code>jti</code>, you can blacklist a <code>jti</code> to prevent a token being used more than X times. In this way you are kind of implementing a nonce (think of the token's signature as the nonce). If a token gets stolen, it should be blacklisted (or the nth token that has been issued after it) and wait for it to expire.


*/
func (a *Client) GetTokens(params *GetTokensParams, authInfo runtime.ClientAuthInfoWriter) (*GetTokensOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTokensParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_tokens",
		Method:             "GET",
		PathPattern:        "/api/v2/blacklists/tokens",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTokensReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTokensOK), nil

}

/*
GetTwilio gets guardian twilio factor provider configuration

Returns provider configuration.

Learn more about <a href="https://auth0.com/docs/multifactor-authentication/administrator/twilio-configuration">Configuring Twilio for Guardian.</a>
*/
func (a *Client) GetTwilio(params *GetTwilioParams, authInfo runtime.ClientAuthInfoWriter) (*GetTwilioOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTwilioParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_twilio",
		Method:             "GET",
		PathPattern:        "/api/v2/guardian/factors/sms/providers/twilio",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTwilioReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTwilioOK), nil

}

/*
GetUserBlocks gets blocks by identifier

This endpoint can be used to retrieve a list of blocked IP addresses for a given key.
*/
func (a *Client) GetUserBlocks(params *GetUserBlocksParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserBlocksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserBlocksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_user-blocks",
		Method:             "GET",
		PathPattern:        "/api/v2/user-blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserBlocksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserBlocksOK), nil

}

/*
GetUserBlocksByID gets a user s blocks

This endpoint can be used to retrieve a list of blocked IP addresses of a particular user given a <code>user_id</code>.
*/
func (a *Client) GetUserBlocksByID(params *GetUserBlocksByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUserBlocksByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUserBlocksByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_user-blocks_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/user-blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUserBlocksByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUserBlocksByIDOK), nil

}

/*
GetUsers lists or search users

This endpoint can be used to retrieve a list of users. With this endpoint it is possible to:

- Specify a search criteria for users
- Sort the users to be returned
- Select the fields to be returned
- Specify the amount of users to retrieve per page and the page number
 <!-- both v2 and v3 are available -->
The <code>q</code> query parameter can be used to get users that match the specified criteria.

- <a href="https://auth0.com/docs/users/search/v3/query-syntax">Query string syntax for user search v3</a> (<code>search_engine=v3</code>).
- <a href="https://auth0.com/docs/users/search/v2/query-syntax">Query string syntax for user search v2</a> (<code>search_engine=v2</code>).

Learn more about searching for users:

- <a href="https://auth0.com/docs/users/search/v3">User Search v3</a>
- <a href="https://auth0.com/docs/users/search/v2">User Search v2</a>
- <a href="https://auth0.com/docs/users/search/best-practices">User Search Best Practices</a>

For information on migrating from user search v2 to v3, see <a href="https://auth0.com/docs/users/search/v3#migrate-from-search-engine-v2-to-v3">Migrate from search engine v2 to v3</a>.

Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.
*/
func (a *Client) GetUsers(params *GetUsersParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_users",
		Method:             "GET",
		PathPattern:        "/api/v2/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersOK), nil

}

/*
GetUsersByEmail searches users by email

The email address associated with a user is saved in lower case, regardless of how you initially provided it. For example, if you register a user as <b>JohnSmith@example.com</b>, Auth0 saves the user's email as <b>johnsmith@example.com</b>.

When using this endpoint, make sure that you are searching for users via email addresses in lowercase only.
*/
func (a *Client) GetUsersByEmail(params *GetUsersByEmailParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersByEmailOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersByEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_users-by-email",
		Method:             "GET",
		PathPattern:        "/api/v2/users-by-email",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUsersByEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersByEmailOK), nil

}

/*
GetUsersByID gets a user

This endpoint can be used to retrieve user details given the <code>user_id</code>.
*/
func (a *Client) GetUsersByID(params *GetUsersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "get_users_by_id",
		Method:             "GET",
		PathPattern:        "/api/v2/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUsersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersByIDOK), nil

}

/*
PatchClientGrantsByID updates a client grant
*/
func (a *Client) PatchClientGrantsByID(params *PatchClientGrantsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchClientGrantsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchClientGrantsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_client-grants_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/client-grants/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchClientGrantsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchClientGrantsByIDOK), nil

}

/*
PatchClientsByID updates a client

<strong>Important:</strong> The <code>client_secret</code> and <code>encryption_key</code> attributes can only be updated with the <code>update:client_keys</code> scope.

*/
func (a *Client) PatchClientsByID(params *PatchClientsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchClientsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchClientsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_clients_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/clients/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchClientsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchClientsByIDOK), nil

}

/*
PatchConnectionsByID updates a connection

<b>Note:</b> if you use the options parameter, the whole options object will be overridden, so ensure that all parameters are present

*/
func (a *Client) PatchConnectionsByID(params *PatchConnectionsByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchConnectionsByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchConnectionsByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_connections_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/connections/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConnectionsByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConnectionsByIDOK), nil

}

/*
PatchEmailTemplatesByTemplateName patches an email template
*/
func (a *Client) PatchEmailTemplatesByTemplateName(params *PatchEmailTemplatesByTemplateNameParams, authInfo runtime.ClientAuthInfoWriter) (*PatchEmailTemplatesByTemplateNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchEmailTemplatesByTemplateNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_email-templates_by_templateName",
		Method:             "PATCH",
		PathPattern:        "/api/v2/email-templates/{templateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchEmailTemplatesByTemplateNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchEmailTemplatesByTemplateNameOK), nil

}

/*
PatchProvider updates the email provider

Can be used to change details for an email provider.

Depending on the type of provider, the <code>credentials</code> object requires different attributes:
<ul><li><code>mandrill</code> requires <code>api_key</code></li><li><code>sendgrid</code> requires <code>api_key</code></li><li><code>sparkpost</code> requires <code>api_key</code></li><li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code> and <code>region</code></li><li><code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code> and <code>smtp_pass</code></li></ul>
<a href="https://auth0.com/docs/email/providers">Learn more about SMTP Email Providers</a>

*/
func (a *Client) PatchProvider(params *PatchProviderParams, authInfo runtime.ClientAuthInfoWriter) (*PatchProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_provider",
		Method:             "PATCH",
		PathPattern:        "/api/v2/emails/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchProviderOK), nil

}

/*
PatchResourceServersByID updates a resource server
*/
func (a *Client) PatchResourceServersByID(params *PatchResourceServersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchResourceServersByIDOK, *PatchResourceServersByIDCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchResourceServersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_resource-servers_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/resource-servers/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchResourceServersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchResourceServersByIDOK:
		return value, nil, nil
	case *PatchResourceServersByIDCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PatchRulesByID updates a rule

Use this endpoint to update an existing rule.

<a href="https://auth0.com/docs/rules">Learn more about rules</a>
*/
func (a *Client) PatchRulesByID(params *PatchRulesByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchRulesByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchRulesByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_rules_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchRulesByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchRulesByIDOK), nil

}

/*
PatchSettings updates tenant settings

Use this endpoint to update various fields for a tenant. Enter the new settings in a JSON string in the body parameter.
*/
func (a *Client) PatchSettings(params *PatchSettingsParams, authInfo runtime.ClientAuthInfoWriter) (*PatchSettingsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchSettingsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_settings",
		Method:             "PATCH",
		PathPattern:        "/api/v2/tenants/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchSettingsOK), nil

}

/*
PatchUsersByID updates a user

Updates a user with the object's properties received in the request's body (the object should be a JSON object).<br/>These are the attributes that can be updated at the root level:<ul><li>blocked</li><li>email_verified</li><li>email</li><li>verify_email</li><li>password</li><li>phone_number</li><li>phone_verified</li><li>user_metadata</li><li>app_metadata</li><li>username</li></ul>Some considerations:<ul><li>The properties of the new object will replace the old ones.</li><li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li><li>If you are updating <code>email_verified</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> you need to specify the <code>connection</code> property too.</li><li>If your are updating <code>email</code> or <code>phone_number</code> you need to specify the <code>connection</code> and the <code>client_id</code> properties.</li><li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API for that.</li></ul><h5>Updating a field (non-metadata property)</h5>To mark the email address of a user as verified, the body to send should be:<pre><code>{ "email_verified": true }</code></pre><h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:<pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>To add the field <code>addresses</code> the body to send should be:<pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
  "user_metadata": {
    "profileCode": 1479,
    "addresses": { "work_address": "100 Industrial Way" }
  }
}</code></pre><h5>Updating an inner user metadata property</h5>Starting from previous user metadata, if we want to add the field <code>"home_address": "742 Evergreen Terrace"</code> in <code>addresses</code> we should send the whole addresses object (since this object is on the first level, it will be merged in, but it's own properties won't). The body to send should be:
<pre><code>{
  "user_metadata": {
    "addresses": {
      "work_address": "100 Industrial Way",
      "home_address": "742 Evergreen Terrace"
    }
  }
}</code></pre>The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
  "user_metadata": {
    "profileCode": 1479,
    "addresses": {
      "work_address": "100 Industrial Way",
      "home_address": "742 Evergreen Terrace"
    }
  }
}</code></pre>

*/
func (a *Client) PatchUsersByID(params *PatchUsersByIDParams, authInfo runtime.ClientAuthInfoWriter) (*PatchUsersByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchUsersByIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patch_users_by_id",
		Method:             "PATCH",
		PathPattern:        "/api/v2/users/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchUsersByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchUsersByIDOK), nil

}

/*
PostClientGrants creates a client grant
*/
func (a *Client) PostClientGrants(params *PostClientGrantsParams, authInfo runtime.ClientAuthInfoWriter) (*PostClientGrantsOK, *PostClientGrantsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostClientGrantsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_client-grants",
		Method:             "POST",
		PathPattern:        "/api/v2/client-grants",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostClientGrantsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostClientGrantsOK:
		return value, nil, nil
	case *PostClientGrantsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostClients creates a client

Creates a new client application. The samples on the right show most attributes that can be used.

We recommend to let us to generate a safe secret for you, but you can also provide your own with the <code>client_secret</code> parameter

*/
func (a *Client) PostClients(params *PostClientsParams, authInfo runtime.ClientAuthInfoWriter) (*PostClientsOK, *PostClientsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostClientsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_clients",
		Method:             "POST",
		PathPattern:        "/api/v2/clients",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostClientsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostClientsOK:
		return value, nil, nil
	case *PostClientsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConnections creates a connection

Creates a new connection according to the JSON object received in <code>body</code>.<br/> The samples on the right show all available attributes. Mandatory attributes are <code>name</code> and <code>strategy</code>.<br/> Valid Strategy names are: <code>ad</code>, <code>adfs</code>, <code>amazon</code>, <code>dropbox</code>, <code>bitbucket</code>, <code>aol</code>, <code>auth0-adldap</code>, <code>auth0-oidc</code>, <code>auth0</code>, <code>baidu</code>, <code>bitly</code>, <code>box</code>, <code>custom</code>, <code>daccount</code>, <code>dwolla</code>, <code>email</code>, <code>evernote-sandbox</code>, <code>evernote</code>, <code>exact</code>, <code>facebook</code>, <code>fitbit</code>, <code>flickr</code>, <code>github</code>, <code>google-apps</code>, <code>google-oauth2</code>, <code>guardian</code>, <code>instagram</code>, <code>ip</code>, <code>linkedin</code>, <code>miicard</code>, <code>oauth1</code>, <code>oauth2</code>, <code>office365</code>, <code>paypal</code>, <code>paypal-sandbox</code>, <code>pingfederate</code>, <code>planningcenter</code>, <code>renren</code>, <code>salesforce-community</code>, <code>salesforce-sandbox</code>, <code>salesforce</code>, <code>samlp</code>, <code>sharepoint</code>, <code>shopify</code>, <code>sms</code>, <code>soundcloud</code>, <code>thecity-sandbox</code>, <code>thecity</code>, <code>thirtysevensignals</code>, <code>twitter</code>, <code>untappd</code>, <code>vkontakte</code>, <code>waad</code>, <code>weibo</code>, <code>windowslive</code>, <code>wordpress</code>, <code>yahoo</code>, <code>yammer</code>, <code>yandex</code>
*/
func (a *Client) PostConnections(params *PostConnectionsParams, authInfo runtime.ClientAuthInfoWriter) (*PostConnectionsOK, *PostConnectionsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostConnectionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_connections",
		Method:             "POST",
		PathPattern:        "/api/v2/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConnectionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConnectionsOK:
		return value, nil, nil
	case *PostConnectionsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostCustomDomains configures a new custom domain

Creates a new custom domain and returns it.

The custom domain will need to be verified before it starts accepting requests.

<a href="https://auth0.com/docs/custom-domains">Learn more about Custom Domains</a>
*/
func (a *Client) PostCustomDomains(params *PostCustomDomainsParams, authInfo runtime.ClientAuthInfoWriter) (*PostCustomDomainsOK, *PostCustomDomainsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCustomDomainsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_custom-domains",
		Method:             "POST",
		PathPattern:        "/api/v2/custom-domains",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostCustomDomainsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostCustomDomainsOK:
		return value, nil, nil
	case *PostCustomDomainsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostDeviceCredentials creates a device public key

Manage the devices that are recognized and authenticated. You can use the device-credentials endpoint using Basic authentication with username and password from a database connection<br />The Authorization header should be <code>Authorization: Basic base64("{db_conn_name}\{user}:{password}")</code>

Please note that Device Credentials endpoints are designed for ad hoc administrative use only.
*/
func (a *Client) PostDeviceCredentials(params *PostDeviceCredentialsParams, authInfo runtime.ClientAuthInfoWriter) (*PostDeviceCredentialsOK, *PostDeviceCredentialsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostDeviceCredentialsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_device-credentials",
		Method:             "POST",
		PathPattern:        "/api/v2/device-credentials",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostDeviceCredentialsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostDeviceCredentialsOK:
		return value, nil, nil
	case *PostDeviceCredentialsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostEmailTemplates creates an email template
*/
func (a *Client) PostEmailTemplates(params *PostEmailTemplatesParams, authInfo runtime.ClientAuthInfoWriter) (*PostEmailTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostEmailTemplatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_email-templates",
		Method:             "POST",
		PathPattern:        "/api/v2/email-templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostEmailTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostEmailTemplatesOK), nil

}

/*
PostEmailVerification creates an email verification ticket

This endpoint can be used to create a ticket to verify a user's email.

Learn more about <a href="https://auth0.com/docs/email/custom#verification-email">Verification Emails.</a>
*/
func (a *Client) PostEmailVerification(params *PostEmailVerificationParams, authInfo runtime.ClientAuthInfoWriter) (*PostEmailVerificationOK, *PostEmailVerificationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostEmailVerificationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_email-verification",
		Method:             "POST",
		PathPattern:        "/api/v2/tickets/email-verification",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostEmailVerificationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostEmailVerificationOK:
		return value, nil, nil
	case *PostEmailVerificationCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostIdentities links a user account

Links the account specified in the body (<strong>secondary account</strong>) to the account specified by the <code>id</code> param of the URL (<strong>primary account</strong>).<br>There are two ways of invoking the endpoint:<br><ul><li>With the authenticated primary account's JWT in the Authorization header, which has the <code>update:current_user_identities</code> scope:
<pre>
POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
Authorization: "Bearer PRIMARY_ACCOUNT_JWT"
{
  "link_with": "SECONDARY_ACCOUNT_JWT"
}
</pre>In this case only the <code>link_with</code> param is required in the body, containing the JWT obtained upon the secondary account's authentication.</li><li>With an API V2 generated token with <code>update:users</code> scope:
<pre>
POST /api/v2/users/PRIMARY_ACCOUNT_USER_ID/identities
Authorization: "Bearer YOUR_API_V2_TOKEN"
{
  "provider": "SECONDARY_ACCOUNT_PROVIDER",
  "connection_id": "SECONDARY_ACCOUNT_CONNECTION_ID(OPTIONAL)",
  "user_id": "SECONDARY_ACCOUNT_USER_ID"
}
</pre>In this case you need to send <code>provider</code> and <code>user_id</code> in the body. Optionally you can also send the <code>connection_id</code> param which is suitable for identifying a particular database connection for the 'auth0' provider.</li></ul>On successful linking, the endpoint returns the new array of the primary account identities.
*/
func (a *Client) PostIdentities(params *PostIdentitiesParams, authInfo runtime.ClientAuthInfoWriter) (*PostIdentitiesOK, *PostIdentitiesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostIdentitiesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_identities",
		Method:             "POST",
		PathPattern:        "/api/v2/users/{id}/identities",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostIdentitiesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostIdentitiesOK:
		return value, nil, nil
	case *PostIdentitiesCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostPasswordChange creates a password change ticket

This endpoint can be used to create a password change ticket for a user.

Learn more about different ways to <a href="https://auth0.com/docs/connections/database/password-change">Change a User's Password.</a>
*/
func (a *Client) PostPasswordChange(params *PostPasswordChangeParams, authInfo runtime.ClientAuthInfoWriter) (*PostPasswordChangeOK, *PostPasswordChangeCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostPasswordChangeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_password-change",
		Method:             "POST",
		PathPattern:        "/api/v2/tickets/password-change",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostPasswordChangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostPasswordChangeOK:
		return value, nil, nil
	case *PostPasswordChangeCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostProvider configures the email provider

To be used to set a new email provider.

Depending on the type of provider, the <code>credentials</code> object requires different attributes:
<ul><li><code>mandrill</code> requires <code>api_key</code></li><li><code>sendgrid</code> requires <code>api_key</code></li><li><code>sparkpost</code> requires <code>api_key</code></li><li><code>ses</code> requires <code>accessKeyId</code>, <code>secretAccessKey</code> and <code>region</code></li><li><code>smtp</code> requires <code>smtp_host</code>, <code>smtp_port</code>, <code>smtp_user</code> and <code>smtp_pass</code></li></ul>
<a href="https://auth0.com/docs/email/providers">Learn more about SMTP Email Providers</a>

*/
func (a *Client) PostProvider(params *PostProviderParams, authInfo runtime.ClientAuthInfoWriter) (*PostProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_provider",
		Method:             "POST",
		PathPattern:        "/api/v2/emails/provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostProviderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProviderOK), nil

}

/*
PostRecoveryCodeRegeneration generates new guardian recovery code

This endpoint removes the current Guardian recovery code then generates and returns a new one.

<a href="https://auth0.com/docs/multifactor-authentication/guardian">Click here to learn more about Guardian</a>
*/
func (a *Client) PostRecoveryCodeRegeneration(params *PostRecoveryCodeRegenerationParams, authInfo runtime.ClientAuthInfoWriter) (*PostRecoveryCodeRegenerationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRecoveryCodeRegenerationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_recovery-code-regeneration",
		Method:             "POST",
		PathPattern:        "/api/v2/users/{id}/recovery-code-regeneration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecoveryCodeRegenerationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecoveryCodeRegenerationOK), nil

}

/*
PostResourceServers creates a resource server
*/
func (a *Client) PostResourceServers(params *PostResourceServersParams, authInfo runtime.ClientAuthInfoWriter) (*PostResourceServersOK, *PostResourceServersCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostResourceServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_resource-servers",
		Method:             "POST",
		PathPattern:        "/api/v2/resource-servers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostResourceServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostResourceServersOK:
		return value, nil, nil
	case *PostResourceServersCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostRotateSecret rotates a client secret

Rotate a client secret. The generated secret is <strong>NOT</strong> base64 encoded.

*/
func (a *Client) PostRotateSecret(params *PostRotateSecretParams, authInfo runtime.ClientAuthInfoWriter) (*PostRotateSecretOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRotateSecretParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_rotate-secret",
		Method:             "POST",
		PathPattern:        "/api/v2/clients/{id}/rotate-secret",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRotateSecretReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRotateSecretOK), nil

}

/*
PostRules creates a rule

Creates a new rule according to the JSON object received in <code>body</code>

The samples on the right show you every attribute that could be used. Mandatory attributes are <code>name</code> and <code>script</code>

<a href="https://auth0.com/docs/rules#create-a-new-rule-using-the-management-api">Learn more about creating a rule</a>

Note: Changing a rule's stage of execution from the default <code>login_success</code> can change the rule's function signature to have user omitted.
*/
func (a *Client) PostRules(params *PostRulesParams, authInfo runtime.ClientAuthInfoWriter) (*PostRulesOK, *PostRulesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_rules",
		Method:             "POST",
		PathPattern:        "/api/v2/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostRulesOK:
		return value, nil, nil
	case *PostRulesCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostTicket creates a guardian enrollment ticket

Generate an email with a link to start the Guardian enrollment process.
*/
func (a *Client) PostTicket(params *PostTicketParams, authInfo runtime.ClientAuthInfoWriter) (*PostTicketOK, *PostTicketNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostTicketParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_ticket",
		Method:             "POST",
		PathPattern:        "/api/v2/guardian/enrollments/ticket",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostTicketReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostTicketOK:
		return value, nil, nil
	case *PostTicketNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostTokens blacklists a token

Adds the token identified by the <code>jti</code> to a blacklist for the tenant.

The <a href="https://auth0.com/docs/jwt">JWT spec</a> provides the <code>jti</code> field as a way to prevent replay attacks. Though Auth0 tokens do not currently return a <code>jti</code>, you can blacklist a <code>jti</code> to prevent a token being used more than X times. In this way you are kind of implementing a nonce (think of the token's signature as the nonce). If a token gets stolen, it should be blacklisted (or the nth token that has been issued after it) and wait for it to expire.
*/
func (a *Client) PostTokens(params *PostTokensParams, authInfo runtime.ClientAuthInfoWriter) (*PostTokensOK, *PostTokensNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostTokensParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_tokens",
		Method:             "POST",
		PathPattern:        "/api/v2/blacklists/tokens",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostTokensReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostTokensOK:
		return value, nil, nil
	case *PostTokensNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostUsers creates a user

Creates a new user according to the JSON object received in <code>body</code>. It works <strong>only</strong> for <a href="https://auth0.com/docs/connections/database">database</a> and <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connections.<br/>
The samples on the right show you every attribute that could be used. The attribute <code>connection</code> is always mandatory but depending on the type of connection you are using there could be others too. For instance, database connections require <code>email</code> and <code>password</code>.

*/
func (a *Client) PostUsers(params *PostUsersParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsersOK, *PostUsersCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_users",
		Method:             "POST",
		PathPattern:        "/api/v2/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostUsersOK:
		return value, nil, nil
	case *PostUsersCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostUsersExports creates job to export users

Export all users to a file using a long running job.
*/
func (a *Client) PostUsersExports(params *PostUsersExportsParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsersExportsOK, *PostUsersExportsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsersExportsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_users-exports",
		Method:             "POST",
		PathPattern:        "/api/v2/jobs/users-exports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostUsersExportsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostUsersExportsOK:
		return value, nil, nil
	case *PostUsersExportsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostUsersImports creates job to import users

Imports users to a connection from a file using a long running job. <strong>Important:</strong> The documentation for the file format is <a href=https://docs.auth0.com/bulk-import>here</a>.
*/
func (a *Client) PostUsersImports(params *PostUsersImportsParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsersImportsOK, *PostUsersImportsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsersImportsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_users-imports",
		Method:             "POST",
		PathPattern:        "/api/v2/jobs/users-imports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostUsersImportsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostUsersImportsOK:
		return value, nil, nil
	case *PostUsersImportsCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostVerificationEmail sends a verify email address email

Send an email to the specified user that asks them to click a link to verify their email address.

<a href="https://auth0.com/docs/email/custom#verification-email">Learn more about Verification Emails</a>

Please note that you must have the `Status` toggle enabled for the verification email template for the email to be sent.

*/
func (a *Client) PostVerificationEmail(params *PostVerificationEmailParams, authInfo runtime.ClientAuthInfoWriter) (*PostVerificationEmailOK, *PostVerificationEmailCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostVerificationEmailParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_verification-email",
		Method:             "POST",
		PathPattern:        "/api/v2/jobs/verification-email",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostVerificationEmailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostVerificationEmailOK:
		return value, nil, nil
	case *PostVerificationEmailCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostVerify verifies a custom domain

Run the verification process for the custom domain. Check the <code>status</code> field to see its verification status.

Once the verification is complete, it might take up to 10 minutes before the custom domain can start accepting requests.

For <code>self_managed_certs</code>, when the custom domain is verified for the first time, the response will also include the <code>cname_api_key</code> which you will need to configure your proxy. This key must be kept secret, and is used to validate the proxy requests.

<a href="https://auth0.com/docs/custom-domains#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Auth0 Managed certificates.
<a href="https://auth0.com/docs/custom-domains/self-managed-certificates#step-2-verify-ownership">Learn more</a> about verifying custom domains that use Self Managed certificates.



*/
func (a *Client) PostVerify(params *PostVerifyParams, authInfo runtime.ClientAuthInfoWriter) (*PostVerifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostVerifyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "post_verify",
		Method:             "POST",
		PathPattern:        "/api/v2/custom-domains/{id}/verify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostVerifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostVerifyOK), nil

}

/*
PutEmailTemplatesByTemplateName updates an email template
*/
func (a *Client) PutEmailTemplatesByTemplateName(params *PutEmailTemplatesByTemplateNameParams, authInfo runtime.ClientAuthInfoWriter) (*PutEmailTemplatesByTemplateNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutEmailTemplatesByTemplateNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put_email-templates_by_templateName",
		Method:             "PUT",
		PathPattern:        "/api/v2/email-templates/{templateName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutEmailTemplatesByTemplateNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutEmailTemplatesByTemplateNameOK), nil

}

/*
PutFactorsByName updates guardian factor

Useful to enable / disable factor.
*/
func (a *Client) PutFactorsByName(params *PutFactorsByNameParams, authInfo runtime.ClientAuthInfoWriter) (*PutFactorsByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutFactorsByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put_factors_by_name",
		Method:             "PUT",
		PathPattern:        "/api/v2/guardian/factors/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutFactorsByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutFactorsByNameOK), nil

}

/*
PutRulesConfigsByKey sets the rules config for a given key

Rules config keys must be of the format <code>^[A-Za-z0-9_\-@*+:]*$</code>.
*/
func (a *Client) PutRulesConfigsByKey(params *PutRulesConfigsByKeyParams, authInfo runtime.ClientAuthInfoWriter) (*PutRulesConfigsByKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutRulesConfigsByKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put_rules-configs_by_key",
		Method:             "PUT",
		PathPattern:        "/api/v2/rules-configs/{key}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRulesConfigsByKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRulesConfigsByKeyOK), nil

}

/*
PutTemplates updates enrollment and verification s m s templates

Useful to send custom messages on SMS enrollment and verification.
*/
func (a *Client) PutTemplates(params *PutTemplatesParams, authInfo runtime.ClientAuthInfoWriter) (*PutTemplatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutTemplatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put_templates",
		Method:             "PUT",
		PathPattern:        "/api/v2/guardian/factors/sms/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutTemplatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutTemplatesOK), nil

}

/*
PutTwilio updates guardian s twilio s m s factor provider

Useful to configure SMS provider.

Learn more about <a href="https://auth0.com/docs/multifactor-authentication/administrator/twilio-configuration">Configuring Twilio for Guardian.</a>
*/
func (a *Client) PutTwilio(params *PutTwilioParams, authInfo runtime.ClientAuthInfoWriter) (*PutTwilioOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutTwilioParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "put_twilio",
		Method:             "PUT",
		PathPattern:        "/api/v2/guardian/factors/sms/providers/twilio",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/x-www-form-urlencoded"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutTwilioReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutTwilioOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
